////////////////////////////////////////////////////////////////////////
// Class:       SimStepsToVTK
// Module Type: analyzer
// File:        SimStepsToVTK_module.cc
//
// Generated at Tue Oct 27 23:04:39 2015 by Adam Lyon using artmod
// from cetpkgsupport v1_08_04.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "gm2catalyst/adapter/CatalystAdapter_service.hh"

#include "gm2ringsim/catalyst/GeantTrackRecord.hh"

#include "vtkSmartPointer.h"
#include "vtkMultiBlockDataSet.h"
#include "vtkPolyData.h"
#include "vtkPoints.h"
#include "vtkCellArray.h"
#include "vtkFloatArray.h"
#include "vtkIntArray.h"
#include "vtkStringArray.h"
#include "vtkPointData.h"
#include "vtkCellData.h"
#include "vtkPolyLine.h"

namespace gm2catalyst {
  class SimStepsToVTK;
}

const std::string vtkDataName = "simSteps";

class gm2catalyst::SimStepsToVTK : public art::EDAnalyzer {
public:
  explicit SimStepsToVTK(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SimStepsToVTK(SimStepsToVTK const &) = delete;
  SimStepsToVTK(SimStepsToVTK &&) = delete;
  SimStepsToVTK & operator = (SimStepsToVTK const &) = delete;
  SimStepsToVTK & operator = (SimStepsToVTK &&) = delete;

  // Required functions.
  void beginJob() override;
  void analyze(art::Event const & e) override;


private:

  std::string geantTrackRecordInputTag_;
  
};


gm2catalyst::SimStepsToVTK::SimStepsToVTK(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  geantTrackRecordInputTag_( p.get<std::string>("geantTrackRecordInputTag", "artg4:KeepStepsAction") )
{}

void gm2catalyst::SimStepsToVTK::beginJob() {
  // Get the CatalystAdapter service and register
  art::ServiceHandle<CatalystAdapter> adapter;
  adapter->registerVTKData(vtkDataName);
}

void gm2catalyst::SimStepsToVTK::analyze(art::Event const & e)
{
  
  // Initialize VTK objects
  
  // Positions and cells
  vtkSmartPointer<vtkPoints>      pts    = vtkSmartPointer<vtkPoints>::New();
  vtkSmartPointer<vtkCellArray>   lines  = vtkSmartPointer<vtkCellArray>::New();
  
  // Cell info (for the track)
  // Parent ID
  vtkSmartPointer<vtkIntArray>    parentID = vtkSmartPointer<vtkIntArray>::New();
  parentID->SetName("parentID");
  
  // Track ID
  vtkSmartPointer<vtkIntArray>    trackID = vtkSmartPointer<vtkIntArray>::New();
  trackID->SetName("trackID");
  
  // Track Status
  vtkSmartPointer<vtkIntArray>    status = vtkSmartPointer<vtkIntArray>::New();
  status->SetName("status");
  
  // PDG
  vtkSmartPointer<vtkIntArray>    pdg = vtkSmartPointer<vtkIntArray>::New();
  pdg->SetName("pdg");
  
  // Point info (for the step)
  // global step -- needs to be float so we can do a good threshold
  vtkSmartPointer<vtkFloatArray>    globalStep = vtkSmartPointer<vtkFloatArray>::New();
  globalStep->SetName("globalStep");
  
  // energyDeposit
  vtkSmartPointer<vtkFloatArray>  energyDep = vtkSmartPointer<vtkFloatArray>::New();
  energyDep->SetName("energyDep");
  
  // stepLength
  vtkSmartPointer<vtkFloatArray>  stepLength = vtkSmartPointer<vtkFloatArray>::New();
  stepLength->SetName("stepLength");
  
  // deltaTime
  vtkSmartPointer<vtkFloatArray>  deltaTime = vtkSmartPointer<vtkFloatArray>::New();
  deltaTime->SetName("deltaTime");
  
  // globalTime
  vtkSmartPointer<vtkFloatArray>  globalTime = vtkSmartPointer<vtkFloatArray>::New();
  globalTime->SetName("globalTime");
  
  // localTime
  vtkSmartPointer<vtkFloatArray>  localTime = vtkSmartPointer<vtkFloatArray>::New();
  localTime->SetName("localTime");
  
  // Momentum
  vtkSmartPointer<vtkFloatArray>  p = vtkSmartPointer<vtkFloatArray>::New();
  p->SetName("p");
  p->SetNumberOfComponents(3);  // each element is a 3-vector
  
  // Spin
  vtkSmartPointer<vtkFloatArray>  s = vtkSmartPointer<vtkFloatArray>::New();
  s->SetName("s");
  s->SetNumberOfComponents(3);  // each element is a 3-vector

  // Get the Geant tracks
  auto gTrkVecH = e.getValidHandle<gm2ringsim::GeantTrackCollection>( geantTrackRecordInputTag_ );
  
  if ( gTrkVecH.isValid() ) {
    auto gTrkVec = *gTrkVecH;
    
    // Loop over tracks
    for ( auto aTrk : gTrkVec ) {
      
      // Get the steps
      bool first = true;
      for ( auto aStep : aTrk.steps() ) {
      
        // Set the position
        vtkIdType pid = pts->InsertNextPoint(&(aStep.pos()[0]));  // Returns the position in the point array
        
        // Fill point arrays
        globalStep->InsertNextValue( aStep.globalStepNum() );
        globalTime->InsertNextValue( aStep.globalTime() );
        localTime->InsertNextValue( aStep.localTime() );
        p->InsertNextTuple( &(aStep.p()[0]) );
        s->InsertNextTuple( &(aStep.s()[0]) );

        // Set the cell (not for the first point)
        if (! first) {
          vtkSmartPointer<vtkPolyLine> polyLine = vtkSmartPointer<vtkPolyLine>::New();
          polyLine->GetPointIds()->InsertNextId(pid-1); // (Previous point)
          polyLine->GetPointIds()->InsertNextId(pid); // (This point)
          lines->InsertNextCell(polyLine);
          
          energyDep->InsertNextValue( aStep.totalEnergyDeposit() );
          stepLength->InsertNextValue( aStep.stepLength() );
          deltaTime->InsertNextValue( aStep.deltaTime() );

          trackID->InsertNextValue( aTrk.trackID() );  // Should put these in a multiblock
          parentID->InsertNextValue( aTrk.parentId() );
          pdg->InsertNextValue( aTrk.pdg() );
          status->InsertNextValue( aTrk.trackStatus() );
        }
        
        // Past stuff for first hit
        first = false;
      
      }
      
      // Done with this track
      
    } // Loop over tracks
    
  } // Are there tracks?
  
  // Make the polydata
  vtkSmartPointer<vtkPolyData> grid = vtkSmartPointer<vtkPolyData>::New();
  grid->SetPoints(pts);
  grid->SetLines(lines);
  grid->GetCellData()->AddArray(trackID);
  grid->GetCellData()->AddArray(parentID);
  grid->GetCellData()->AddArray(pdg);
  grid->GetCellData()->AddArray(status);
  grid->GetCellData()->AddArray(energyDep);
  grid->GetCellData()->AddArray(stepLength);
  grid->GetCellData()->AddArray(deltaTime);
  grid->GetPointData()->AddArray(globalStep);
  grid->GetPointData()->AddArray(globalTime);
  grid->GetPointData()->AddArray(localTime);
  grid->GetPointData()->AddArray(p);
  grid->GetPointData()->AddArray(s);
  
  // Give this to the adapter service
  art::ServiceHandle<CatalystAdapter> adapter;
  adapter->giveVTKData(vtkDataName, grid);
}

DEFINE_ART_MODULE(gm2catalyst::SimStepsToVTK)
