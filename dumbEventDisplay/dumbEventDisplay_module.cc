////////////////////////////////////////////////////////////////////////
// Class:       dumbEventDisplay
// Module Type: analyzer
// File:        dumbEventDisplay_module.cc
//
// Generated at Tue Oct 20 14:55:09 2015 by Adam Lyon using artmod
// from cetpkgsupport v1_08_04.
////////////////////////////////////////////////////////////////////////

#include <unistd.h>  // for sleep

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"

// Random number generator stuff
#include "CLHEP/Random/RandFlat.h"
#include "CLHEP/Random/RandGaussQ.h"

// The vtk headers have extra ; that trip up the pedantic warnings as errors

#include "vtkNew.h"
#include "vtkCPProcessor.h"
#include "vtkCPDataDescription.h"
#include "vtkCPInputDataDescription.h"
#include "vtkCPPythonScriptPipeline.h"

#include "vtkPolyData.h"
#include "vtkConeSource.h"
#include "vtkSphereSource.h"



namespace pvc {
  class dumbEventDisplay;
}

class pvc::dumbEventDisplay : public art::EDAnalyzer {
public:
  explicit dumbEventDisplay(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  dumbEventDisplay(dumbEventDisplay const &) = delete;
  dumbEventDisplay(dumbEventDisplay &&) = delete;
  dumbEventDisplay & operator = (dumbEventDisplay const &) = delete;
  dumbEventDisplay & operator = (dumbEventDisplay &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

private:

  std::string pipelinePythonScript_;
  int sleepSec_;

  CLHEP::HepRandomEngine& engine_;  // this can be a reference because it is created by createEngine, which returns a ref
  CLHEP::RandFlat flatGen_;  // this cannot be a reference, because we create it with its c'tor
  
  vtkCPProcessor* catalystProcessor_ = nullptr;
  
};


pvc::dumbEventDisplay::dumbEventDisplay(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  pipelinePythonScript_( p.get<std::string>("pipelinePythonScript")),
  sleepSec_( p.get<int>("sleepSec", 1)),
  engine_( createEngine(get_seed_value(p))),
  flatGen_( engine_ ),
  catalystProcessor_( vtkCPProcessor::New() )
{
  catalystProcessor_->Initialize();
  vtkNew<vtkCPPythonScriptPipeline> pipeline;
  pipeline->Initialize(pipelinePythonScript_.c_str());
  catalystProcessor_->AddPipeline(pipeline.GetPointer());                                  
}

void pvc::dumbEventDisplay::analyze(art::Event const & e)
{
  // Does the pipeline want us to do anything?
  vtkNew<vtkCPDataDescription> dataDescription;
  dataDescription->AddInput("input");
  dataDescription->AddInput("input2");
  dataDescription->SetTimeData( e.event(), e.event() );
  
  // Are we going to send this event to the pipeline?
  if ( catalystProcessor_->RequestDataDescription(dataDescription.GetPointer()) != 0 ){
    
    // Yes!

    // Build the VTK structures
    vtkConeSource* cone = vtkConeSource::New();
    cone->SetHeight( flatGen_.fire()*100.0 );
    cone->SetRadius( flatGen_.fire()*100.0 );
    cone->SetResolution(50);
    cone->Update();
    vtkPolyData* polyData = cone->GetOutput();
    
    // Let's make a sphere too!
    vtkSphereSource* sphere = vtkSphereSource::New();
    sphere->SetCenter( flatGen_.fire()*100.0, flatGen_.fire()*100.0, flatGen_.fire()*100.0 );
    sphere->SetRadius( flatGen_.fire()*100.0 );
    sphere->SetThetaResolution( flatGen_.fire()*100.0 );
    sphere->SetPhiResolution( flatGen_.fire()*100.0 );
    sphere->Update();
    vtkPolyData* spherePolyData = sphere->GetOutput();
    
    
    // Feed it to the Catalyst server
    dataDescription->GetInputDescriptionByName("input")->SetGrid(polyData);
    dataDescription->GetInputDescriptionByName("input2")->SetGrid(spherePolyData);
    catalystProcessor_->CoProcess(dataDescription.GetPointer());  // Go!
    
    // Now pause
    //std::cout << "Event #" << e.event() << "  Pausing... " << std::endl;
    //std::cin.ignore();
    sleep(sleepSec_);
  }
  
}
DEFINE_ART_MODULE(pvc::dumbEventDisplay)
